@page "/weather"
@implements IDisposable

<PageTitle>Weather</PageTitle>

<div class="weather-container">
    <div class="weather-header">
        <MudText Typo="Typo.h3" GutterBottom="true" Style="word-break: break-word;">Weather forecast</MudText>
        <MudText Typo="Typo.body1" Class="mb-4" Style="word-break: break-word;">This component demonstrates fetching data from the server. Total forecasts: @(forecasts?.Length.ToString("N0") ?? "Loading...") | Showing: @(filteredForecasts?.Count().ToString("N0") ?? "0")</MudText>
    </div>

    @if (forecasts == null)
    {
        <MudProgressCircular Color="Color.Default" Indeterminate="true"/>
    }
    else
    {
        <div class="search-bar mb-3">
            <MudTextField Value="@searchString"
                          ValueChanged="@((string value) => OnSearchChanged(value))"
                          Placeholder="Search across all fields..."
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="true"
                          Clearable="true"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          Disabled="@isFiltering"/>
        </div>
        <div class="weather-table-container">
            @if (isFiltering)
            {
                <div class="filtering-overlay">
                    <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
                    <MudText Typo="Typo.body2" Class="ml-2">Filtering...</MudText>
                </div>
            }
            <MudTable Items="filteredForecasts"
                      Hover="false"
                      Virtualize="true"
                      FixedHeader="true"
                      Height="100%"
                      Dense="true">
                <HeaderContent>
                    <MudTh>ID</MudTh>
                    <MudTh>Date</MudTh>
                    <MudTh>Temp. (C)</MudTh>
                    <MudTh>Temp. (F)</MudTh>
                    <MudTh>Summary</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="ID">@context.Id</MudTd>
                    <MudTd DataLabel="Date">@context.Date</MudTd>
                    <MudTd DataLabel="Temp. (C)">@context.TemperatureC</MudTd>
                    <MudTd DataLabel="Temp. (F)">@context.TemperatureF</MudTd>
                    <MudTd DataLabel="Summary">@context.Summary</MudTd>
                </RowTemplate>
            </MudTable>
        </div>
    }
</div>

<style>
    .weather-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        max-height: 100%;
    }

    .weather-header {
        flex-shrink: 0;
    }

    .weather-table-container {
        flex: 1;
        min-height: 0;
        overflow: hidden;
    }

    .weather-table-container .mud-table {
        height: 100%;
    }

    .filtering-overlay {
        display: flex;
        align-items: center;
        padding: 8px;
        background: rgba(0, 0, 0, 0.03);
        border-radius: 4px;
        margin-bottom: 8px;
    }
</style>

@code {
    private WeatherForecast[]? forecasts;
    private List<WeatherForecast> filteredForecasts = new();
    private string searchString = string.Empty;
    private bool isFiltering = false;
    private CancellationTokenSource? debounceTokenSource;
    private const int DebounceMilliseconds = 300;

    protected override async Task OnInitializedAsync()
    {
        await Task.Delay(500);

        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };

        forecasts = new WeatherForecast[200_000];
        for (int i = 0; i < forecasts.Length; i++)
        {
            var tempC = Random.Shared.Next(-20, 55);
            forecasts[i] = new WeatherForecast
            {
                Id = i + 1,
                Date = startDate.AddDays(i + 1),
                TemperatureC = tempC,
                TemperatureF = 32 + (int)(tempC / 0.5556),
                Summary = summaries[Random.Shared.Next(summaries.Length)]
            };
        }

        filteredForecasts = forecasts.ToList();
    }

    private async Task OnSearchChanged(string value)
    {
        searchString = value;

        debounceTokenSource?.Cancel();
        debounceTokenSource = new CancellationTokenSource();
        var token = debounceTokenSource.Token;

        try
        {
            await Task.Delay(DebounceMilliseconds, token);
            await FilterDataAsync(token);
        }
        catch (TaskCanceledException)
        {
        }
    }

    private async Task FilterDataAsync(CancellationToken cancellationToken)
    {
        if (forecasts == null) return;

        isFiltering = true;
        StateHasChanged();

        try
        {
            var results = await Task.Run(() =>
            {
                if (string.IsNullOrWhiteSpace(searchString))
                {
                    return forecasts.ToList();
                }

                return forecasts.Where(f =>
                    f.Id.ToString().Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
                    f.Date.ToString().Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
                    f.TemperatureC.ToString().Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
                    f.TemperatureF.ToString().Contains(searchString, StringComparison.OrdinalIgnoreCase) ||
                    (f.Summary?.Contains(searchString, StringComparison.OrdinalIgnoreCase) ?? false)
                ).ToList();
            }, cancellationToken);

            if (!cancellationToken.IsCancellationRequested)
            {
                filteredForecasts = results;
            }
        }
        finally
        {
            isFiltering = false;
            StateHasChanged();
        }
    }

    public void Dispose()
    {
        debounceTokenSource?.Cancel();
        debounceTokenSource?.Dispose();
    }

    private sealed class WeatherForecast
    {
        public int Id { get; set; }
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public int TemperatureF { get; set; }
        public string? Summary { get; set; }
    }

}
